{"ast":null,"code":"var _jsxFileName = \"/Users/katherynrojas/Documents/reconocimiento-facial-react-node/frontend/src/VideoChat.js\",\n  _s = $RefreshSig$();\n/*import React, { useEffect, useRef, useState } from 'react';\nimport Peer from 'simple-peer';\nimport * as faceapi from 'face-api.js';\nimport io from 'socket.io-client';\n\n// const socket = io.connect('http://localhost:5000');\nconst socket = io.connect('https://glrtzw7g-5000.use2.devtunnels.ms'); // URL del backend\n\n\n\nconst VideoChat = () => {\n  const [stream, setStream] = useState(null);\n  const [me, setMe] = useState(\"\");\n  const [peer, setPeer] = useState(null);\n  const myVideoRef = useRef();\n  const userVideoRef = useRef();\n  const [detections, setDetections] = useState(null);\n  const [modelsLoaded, setModelsLoaded] = useState(false); // Estado para controlar la carga de modelos\n\n  // Cargar los modelos de face-api.js\n  const loadModels = async () => {\n    await faceapi.nets.tinyFaceDetector.loadFromUri('/models');\n    await faceapi.nets.faceLandmark68Net.loadFromUri('/models');\n    await faceapi.nets.faceRecognitionNet.loadFromUri('/models');\n    setModelsLoaded(true); // Cambiar el estado a true una vez que los modelos se hayan cargado\n    console.log('Modelos cargados');\n  };\n\n  useEffect(() => {\n    loadModels(); // Llama a loadModels al montar el componente\n\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(stream => {\n      setStream(stream);\n      if (myVideoRef.current) {\n        myVideoRef.current.srcObject = stream;\n      }\n    });\n\n    socket.on('me', (id) => {\n      setMe(id);\n    });\n  }, []);\n\n  // Detectar rostros en tiempo real solo si los modelos están cargados\n  useEffect(() => {\n    const detectFaces = async () => {\n      if (myVideoRef.current && stream) {\n        const detections = await faceapi.detectAllFaces(\n          myVideoRef.current,\n          new faceapi.TinyFaceDetectorOptions()\n        ).withFaceLandmarks().withFaceDescriptors();\n        setDetections(detections);\n      }\n    };\n\n    const interval = setInterval(() => {\n      if (modelsLoaded) {\n        detectFaces(); // Ejecutar la detección solo si los modelos están cargados\n      }\n    }, 100);\n\n    return () => clearInterval(interval);\n  }, [stream, modelsLoaded]);\n\n  const startPeer = (initiator) => {\n    const newPeer = new Peer({ initiator, trickle: false, stream });\n\n    newPeer.on('signal', (data) => {\n      socket.emit('signal', { to: \"partner-id\", signal: data });\n    });\n\n    newPeer.on('stream', (userStream) => {\n      if (userVideoRef.current) {\n        userVideoRef.current.srcObject = userStream;\n      }\n    });\n\n    socket.on('signal', (signalData) => {\n      newPeer.signal(signalData.signal);\n    });\n\n    setPeer(newPeer);\n  };\n\n  return (\n    <div>\n      <h1>Video Chat con Reconocimiento Facial</h1>\n\n      <video ref={myVideoRef} autoPlay muted style={{ width: '300px' }} />\n      <video ref={userVideoRef} autoPlay style={{ width: '300px' }} />\n\n      <button onClick={() => startPeer(true)}>Iniciar llamada</button>\n      <button onClick={() => startPeer(false)}>Unirse a llamada</button>\n\n      {detections && (\n        <div>\n          <h2>Detecciones:</h2>\n          <pre>{JSON.stringify(detections, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VideoChat;*/\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport io from 'socket.io-client';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst socket = io('http://localhost:5000'); // Cambia esto si usas un túnel\n\nconst VideoChat = () => {\n  _s();\n  const [remoteStream, setRemoteStream] = useState(null);\n  const localVideoRef = useRef(null);\n  const remoteVideoRef = useRef(null);\n  const peerConnection = useRef(new RTCPeerConnection({\n    iceServers: [{\n      urls: 'stun:stun.l.google.com:19302'\n    }]\n  }));\n  useEffect(() => {\n    // Manejar la conexión de video local\n    navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: true\n    }).then(stream => {\n      localVideoRef.current.srcObject = stream;\n      stream.getTracks().forEach(track => {\n        peerConnection.current.addTrack(track, stream);\n      });\n    });\n\n    // Escuchar eventos de Socket.io\n    socket.on('callReceived', data => {\n      const {\n        from\n      } = data;\n      startCall(from);\n    });\n    socket.on('callOffer', async data => {\n      const {\n        offer,\n        from\n      } = data;\n      await peerConnection.current.setRemoteDescription(new RTCSessionDescription(offer));\n      const answer = await peerConnection.current.createAnswer();\n      await peerConnection.current.setLocalDescription(answer);\n      socket.emit('callAnswer', {\n        answer,\n        to: from\n      });\n    });\n    socket.on('callAnswer', async data => {\n      const {\n        answer\n      } = data;\n      await peerConnection.current.setRemoteDescription(new RTCSessionDescription(answer));\n    });\n    peerConnection.current.ontrack = event => {\n      setRemoteStream(event.streams[0]);\n      remoteVideoRef.current.srcObject = event.streams[0];\n    };\n\n    // Manejar ICE candidates\n    peerConnection.current.onicecandidate = event => {\n      if (event.candidate) {\n        socket.emit('iceCandidate', {\n          candidate: event.candidate,\n          to: recipientId\n        });\n      }\n    };\n    return () => {\n      socket.off('callReceived');\n      socket.off('callOffer');\n      socket.off('callAnswer');\n    };\n  }, []);\n  const startCall = async recipientId => {\n    const offer = await peerConnection.current.createOffer();\n    await peerConnection.current.setLocalDescription(offer);\n    socket.emit('startCall', {\n      recipientId\n    });\n    socket.emit('callOffer', {\n      offer,\n      to: recipientId\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: localVideoRef,\n      autoPlay: true,\n      muted: true,\n      style: {\n        width: '300px'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"video\", {\n      ref: remoteVideoRef,\n      autoPlay: true,\n      style: {\n        width: '300px'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 178,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 176,\n    columnNumber: 9\n  }, this);\n};\n_s(VideoChat, \"jyjUyrKAZw+GkjSNggzgObdbgLI=\");\n_c = VideoChat;\nexport default VideoChat;\nvar _c;\n$RefreshReg$(_c, \"VideoChat\");","map":{"version":3,"names":["React","useEffect","useRef","useState","io","jsxDEV","_jsxDEV","socket","VideoChat","_s","remoteStream","setRemoteStream","localVideoRef","remoteVideoRef","peerConnection","RTCPeerConnection","iceServers","urls","navigator","mediaDevices","getUserMedia","video","audio","then","stream","current","srcObject","getTracks","forEach","track","addTrack","on","data","from","startCall","offer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","setLocalDescription","emit","to","ontrack","event","streams","onicecandidate","candidate","recipientId","off","createOffer","children","ref","autoPlay","muted","style","width","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/katherynrojas/Documents/reconocimiento-facial-react-node/frontend/src/VideoChat.js"],"sourcesContent":["/*import React, { useEffect, useRef, useState } from 'react';\nimport Peer from 'simple-peer';\nimport * as faceapi from 'face-api.js';\nimport io from 'socket.io-client';\n\n// const socket = io.connect('http://localhost:5000');\nconst socket = io.connect('https://glrtzw7g-5000.use2.devtunnels.ms'); // URL del backend\n\n\n\nconst VideoChat = () => {\n  const [stream, setStream] = useState(null);\n  const [me, setMe] = useState(\"\");\n  const [peer, setPeer] = useState(null);\n  const myVideoRef = useRef();\n  const userVideoRef = useRef();\n  const [detections, setDetections] = useState(null);\n  const [modelsLoaded, setModelsLoaded] = useState(false); // Estado para controlar la carga de modelos\n\n  // Cargar los modelos de face-api.js\n  const loadModels = async () => {\n    await faceapi.nets.tinyFaceDetector.loadFromUri('/models');\n    await faceapi.nets.faceLandmark68Net.loadFromUri('/models');\n    await faceapi.nets.faceRecognitionNet.loadFromUri('/models');\n    setModelsLoaded(true); // Cambiar el estado a true una vez que los modelos se hayan cargado\n    console.log('Modelos cargados');\n  };\n\n  useEffect(() => {\n    loadModels(); // Llama a loadModels al montar el componente\n\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(stream => {\n      setStream(stream);\n      if (myVideoRef.current) {\n        myVideoRef.current.srcObject = stream;\n      }\n    });\n\n    socket.on('me', (id) => {\n      setMe(id);\n    });\n  }, []);\n\n  // Detectar rostros en tiempo real solo si los modelos están cargados\n  useEffect(() => {\n    const detectFaces = async () => {\n      if (myVideoRef.current && stream) {\n        const detections = await faceapi.detectAllFaces(\n          myVideoRef.current,\n          new faceapi.TinyFaceDetectorOptions()\n        ).withFaceLandmarks().withFaceDescriptors();\n        setDetections(detections);\n      }\n    };\n\n    const interval = setInterval(() => {\n      if (modelsLoaded) {\n        detectFaces(); // Ejecutar la detección solo si los modelos están cargados\n      }\n    }, 100);\n\n    return () => clearInterval(interval);\n  }, [stream, modelsLoaded]);\n\n  const startPeer = (initiator) => {\n    const newPeer = new Peer({ initiator, trickle: false, stream });\n\n    newPeer.on('signal', (data) => {\n      socket.emit('signal', { to: \"partner-id\", signal: data });\n    });\n\n    newPeer.on('stream', (userStream) => {\n      if (userVideoRef.current) {\n        userVideoRef.current.srcObject = userStream;\n      }\n    });\n\n    socket.on('signal', (signalData) => {\n      newPeer.signal(signalData.signal);\n    });\n\n    setPeer(newPeer);\n  };\n\n  return (\n    <div>\n      <h1>Video Chat con Reconocimiento Facial</h1>\n\n      <video ref={myVideoRef} autoPlay muted style={{ width: '300px' }} />\n      <video ref={userVideoRef} autoPlay style={{ width: '300px' }} />\n\n      <button onClick={() => startPeer(true)}>Iniciar llamada</button>\n      <button onClick={() => startPeer(false)}>Unirse a llamada</button>\n\n      {detections && (\n        <div>\n          <h2>Detecciones:</h2>\n          <pre>{JSON.stringify(detections, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VideoChat;*/\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport io from 'socket.io-client';\n\nconst socket = io('http://localhost:5000'); // Cambia esto si usas un túnel\n\nconst VideoChat = () => {\n    const [remoteStream, setRemoteStream] = useState(null);\n    const localVideoRef = useRef(null);\n    const remoteVideoRef = useRef(null);\n    const peerConnection = useRef(new RTCPeerConnection({\n        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]\n    }));\n\n    useEffect(() => {\n        // Manejar la conexión de video local\n        navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n            .then(stream => {\n                localVideoRef.current.srcObject = stream;\n                stream.getTracks().forEach(track => {\n                    peerConnection.current.addTrack(track, stream);\n                });\n            });\n\n        // Escuchar eventos de Socket.io\n        socket.on('callReceived', (data) => {\n            const { from } = data;\n            startCall(from);\n        });\n\n        socket.on('callOffer', async (data) => {\n            const { offer, from } = data;\n            await peerConnection.current.setRemoteDescription(new RTCSessionDescription(offer));\n            const answer = await peerConnection.current.createAnswer();\n            await peerConnection.current.setLocalDescription(answer);\n            socket.emit('callAnswer', { answer, to: from });\n        });\n\n        socket.on('callAnswer', async (data) => {\n            const { answer } = data;\n            await peerConnection.current.setRemoteDescription(new RTCSessionDescription(answer));\n        });\n\n        peerConnection.current.ontrack = (event) => {\n            setRemoteStream(event.streams[0]);\n            remoteVideoRef.current.srcObject = event.streams[0];\n        };\n\n        // Manejar ICE candidates\n        peerConnection.current.onicecandidate = (event) => {\n            if (event.candidate) {\n                socket.emit('iceCandidate', { candidate: event.candidate, to: recipientId });\n            }\n        };\n\n        return () => {\n            socket.off('callReceived');\n            socket.off('callOffer');\n            socket.off('callAnswer');\n        };\n    }, []);\n\n    const startCall = async (recipientId) => {\n        const offer = await peerConnection.current.createOffer();\n        await peerConnection.current.setLocalDescription(offer);\n        socket.emit('startCall', { recipientId });\n        socket.emit('callOffer', { offer, to: recipientId });\n    };\n\n    return (\n        <div>\n            <video ref={localVideoRef} autoPlay muted style={{ width: '300px' }} />\n            <video ref={remoteVideoRef} autoPlay style={{ width: '300px' }} />\n        </div>\n    );\n};\n\nexport default VideoChat;\n\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAC1D,OAAOC,EAAE,MAAM,kBAAkB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAElC,MAAMC,MAAM,GAAGH,EAAE,CAAC,uBAAuB,CAAC,CAAC,CAAC;;AAE5C,MAAMI,SAAS,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACpB,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGR,QAAQ,CAAC,IAAI,CAAC;EACtD,MAAMS,aAAa,GAAGV,MAAM,CAAC,IAAI,CAAC;EAClC,MAAMW,cAAc,GAAGX,MAAM,CAAC,IAAI,CAAC;EACnC,MAAMY,cAAc,GAAGZ,MAAM,CAAC,IAAIa,iBAAiB,CAAC;IAChDC,UAAU,EAAE,CAAC;MAAEC,IAAI,EAAE;IAA+B,CAAC;EACzD,CAAC,CAAC,CAAC;EAEHhB,SAAS,CAAC,MAAM;IACZ;IACAiB,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;MAAEC,KAAK,EAAE,IAAI;MAAEC,KAAK,EAAE;IAAK,CAAC,CAAC,CAC5DC,IAAI,CAACC,MAAM,IAAI;MACZZ,aAAa,CAACa,OAAO,CAACC,SAAS,GAAGF,M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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}