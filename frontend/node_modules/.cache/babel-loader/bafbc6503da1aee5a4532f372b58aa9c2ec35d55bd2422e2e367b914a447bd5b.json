{"ast":null,"code":"import React,{useEffect,useRef,useState}from'react';import Peer from'simple-peer';import*as faceapi from'face-api.js';import io from'socket.io-client';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const socket=io.connect('http://localhost:5000');const VideoChat=()=>{const[stream,setStream]=useState(null);const[me,setMe]=useState(\"\");const[peer,setPeer]=useState(null);const myVideoRef=useRef();const userVideoRef=useRef();const[detections,setDetections]=useState(null);const[modelsLoaded,setModelsLoaded]=useState(false);// Estado para controlar la carga de modelos\n// Cargar los modelos de face-api.js\nconst loadModels=async()=>{await faceapi.nets.tinyFaceDetector.loadFromUri('/models');await faceapi.nets.faceLandmark68Net.loadFromUri('/models');await faceapi.nets.faceRecognitionNet.loadFromUri('/models');setModelsLoaded(true);// Cambiar el estado a true una vez que los modelos se hayan cargado\nconsole.log('Modelos cargados');};useEffect(()=>{loadModels();// Llama a loadModels al montar el componente\nnavigator.mediaDevices.getUserMedia({video:true,audio:true}).then(stream=>{setStream(stream);if(myVideoRef.current){myVideoRef.current.srcObject=stream;}});socket.on('me',id=>{setMe(id);});},[]);// Detectar rostros en tiempo real solo si los modelos están cargados\nuseEffect(()=>{const detectFaces=async()=>{if(myVideoRef.current&&stream){const detections=await faceapi.detectAllFaces(myVideoRef.current,new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptors();setDetections(detections);}};const interval=setInterval(()=>{if(modelsLoaded){detectFaces();// Ejecutar la detección solo si los modelos están cargados\n}},100);return()=>clearInterval(interval);},[stream,modelsLoaded]);const startPeer=initiator=>{const newPeer=new Peer({initiator,trickle:false,stream});newPeer.on('signal',data=>{socket.emit('signal',{to:\"partner-id\",signal:data});});newPeer.on('stream',userStream=>{if(userVideoRef.current){userVideoRef.current.srcObject=userStream;}});socket.on('signal',signalData=>{newPeer.signal(signalData.signal);});setPeer(newPeer);};return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"h1\",{children:\"Video Chat con Reconocimiento Facial\"}),/*#__PURE__*/_jsx(\"video\",{ref:myVideoRef,autoPlay:true,muted:true,style:{width:'300px'}}),/*#__PURE__*/_jsx(\"video\",{ref:userVideoRef,autoPlay:true,style:{width:'300px'}}),/*#__PURE__*/_jsx(\"button\",{onClick:()=>startPeer(true),children:\"Iniciar llamada\"}),/*#__PURE__*/_jsx(\"button\",{onClick:()=>startPeer(false),children:\"Unirse a llamada\"}),detections&&/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"h2\",{children:\"Detecciones:\"}),/*#__PURE__*/_jsx(\"pre\",{children:JSON.stringify(detections,null,2)})]})]});};export default VideoChat;","map":{"version":3,"names":["React","useEffect","useRef","useState","Peer","faceapi","io","jsx","_jsx","jsxs","_jsxs","socket","connect","VideoChat","stream","setStream","me","setMe","peer","setPeer","myVideoRef","userVideoRef","detections","setDetections","modelsLoaded","setModelsLoaded","loadModels","nets","tinyFaceDetector","loadFromUri","faceLandmark68Net","faceRecognitionNet","console","log","navigator","mediaDevices","getUserMedia","video","audio","then","current","srcObject","on","id","detectFaces","detectAllFaces","TinyFaceDetectorOptions","withFaceLandmarks","withFaceDescriptors","interval","setInterval","clearInterval","startPeer","initiator","newPeer","trickle","data","emit","to","signal","userStream","signalData","children","ref","autoPlay","muted","style","width","onClick","JSON","stringify"],"sources":["/Users/katherynrojas/Documents/reconocimiento-facial-react-node/frontend/src/VideoChat.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport Peer from 'simple-peer';\nimport * as faceapi from 'face-api.js';\nimport io from 'socket.io-client';\n\nconst socket = io.connect('http://localhost:5000');\n\nconst VideoChat = () => {\n  const [stream, setStream] = useState(null);\n  const [me, setMe] = useState(\"\");\n  const [peer, setPeer] = useState(null);\n  const myVideoRef = useRef();\n  const userVideoRef = useRef();\n  const [detections, setDetections] = useState(null);\n  const [modelsLoaded, setModelsLoaded] = useState(false); // Estado para controlar la carga de modelos\n\n  // Cargar los modelos de face-api.js\n  const loadModels = async () => {\n    await faceapi.nets.tinyFaceDetector.loadFromUri('/models');\n    await faceapi.nets.faceLandmark68Net.loadFromUri('/models');\n    await faceapi.nets.faceRecognitionNet.loadFromUri('/models');\n    setModelsLoaded(true); // Cambiar el estado a true una vez que los modelos se hayan cargado\n    console.log('Modelos cargados');\n  };\n\n  useEffect(() => {\n    loadModels(); // Llama a loadModels al montar el componente\n\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(stream => {\n      setStream(stream);\n      if (myVideoRef.current) {\n        myVideoRef.current.srcObject = stream;\n      }\n    });\n\n    socket.on('me', (id) => {\n      setMe(id);\n    });\n  }, []);\n\n  // Detectar rostros en tiempo real solo si los modelos están cargados\n  useEffect(() => {\n    const detectFaces = async () => {\n      if (myVideoRef.current && stream) {\n        const detections = await faceapi.detectAllFaces(\n          myVideoRef.current,\n          new faceapi.TinyFaceDetectorOptions()\n        ).withFaceLandmarks().withFaceDescriptors();\n        setDetections(detections);\n      }\n    };\n\n    const interval = setInterval(() => {\n      if (modelsLoaded) {\n        detectFaces(); // Ejecutar la detección solo si los modelos están cargados\n      }\n    }, 100);\n\n    return () => clearInterval(interval);\n  }, [stream, modelsLoaded]);\n\n  const startPeer = (initiator) => {\n    const newPeer = new Peer({ initiator, trickle: false, stream });\n\n    newPeer.on('signal', (data) => {\n      socket.emit('signal', { to: \"partner-id\", signal: data });\n    });\n\n    newPeer.on('stream', (userStream) => {\n      if (userVideoRef.current) {\n        userVideoRef.current.srcObject = userStream;\n      }\n    });\n\n    socket.on('signal', (signalData) => {\n      newPeer.signal(signalData.signal);\n    });\n\n    setPeer(newPeer);\n  };\n\n  return (\n    <div>\n      <h1>Video Chat con Reconocimiento Facial</h1>\n\n      <video ref={myVideoRef} autoPlay muted style={{ width: '300px' }} />\n      <video ref={userVideoRef} autoPlay style={{ width: '300px' }} />\n\n      <button onClick={() => startPeer(true)}>Iniciar llamada</button>\n      <button onClick={() => startPeer(false)}>Unirse a llamada</button>\n\n      {detections && (\n        <div>\n          <h2>Detecciones:</h2>\n          <pre>{JSON.stringify(detections, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VideoChat;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}